<!-- Transform Grid Component -->
<div class="transform-grid-component">
  <div class="row g-4" id="transformGridContainer">
    <!-- Grid items will appear here -->
  </div>
  
  <div class="d-flex gap-2 mt-4">
    <!-- Add Item Button -->
    <button type="button" class="btn btn-sm btn-outline-primary" id="addItemBtn">
      <i class="bi bi-plus-circle me-1"></i> Add Item
    </button>
    
    <!-- Save Button -->
    <button type="button" class="btn btn-sm btn-success" id="saveGridBtn">
      <i class="bi bi-check-circle me-1"></i> Save Changes
    </button>
  </div>
</div>

<!-- Alert container -->
<div class="alert-container position-fixed bottom-0 end-0 p-3" style="z-index: 1050;">
  <div id="gridSuccessAlert" class="alert alert-success d-flex align-items-center mb-0 d-none">
    <i class="bi bi-check-circle-fill me-2"></i>
    <div>
      <strong>Success!</strong> Your changes have been saved.
    </div>
  </div>
</div>

<!-- Add CKEditor script -->
<script src="https://cdn.ckeditor.com/ckeditor5/39.0.1/decoupled-document/ckeditor.js"></script>
<!-- Add marked library for markdown parsing -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Configure marked to allow HTML
    marked.setOptions({
      sanitize: false,  // Allow HTML in the input
      gfm: true,        // GitHub Flavored Markdown
      breaks: true      // Convert line breaks to <br>
    });

    const addItemBtn = document.getElementById('addItemBtn');
    const saveGridBtn = document.getElementById('saveGridBtn');
    const gridContainer = document.getElementById('transformGridContainer');
    
    // Array to store grid items
    let gridItems = [];
    let contentId = null;
    
    // Get content ID from URL parameters
    const getContentId = () => {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('id');
    };
    
    // Fetch grid items from API
    const fetchGridItems = async () => {
      contentId = getContentId();
      
      if (!contentId) {
        console.error('No content ID found');
        return;
      }
      
      try {
        const response = await fetch(`/api/content/id/${contentId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('Network response was not ok: ' + response.statusText);
        }
        
        const data = await response.json();
        
        // Clear the grid
        gridContainer.innerHTML = '';
        gridItems = [];
        
        // Check if we have fields in the response
        if (data && data.fields && Array.isArray(data.fields) && data.fields.length > 0) {
          // Store items and render them
          gridItems = data.fields.map(field => {
            const content = field.value?.content || '';
            // Try to parse the content as markdown, fallback to original content if it fails
            let parsedContent = content;
            try {
              parsedContent = marked.parse(content);
            } catch (error) {
              console.error('Error parsing markdown:', error);
            }
            
            return {
              id: field.id || 'item-' + Date.now(),
              url: field.value?.url || '/images/placeholder.png',
              title: field.value?.title || '',
              content: parsedContent
            };
          });
          
          gridItems.forEach(item => {
            addItemToGrid(item);
          });
        }
      } catch (error) {
        console.error('Error fetching grid items:', error);
      }
    };
    
    // Save grid changes
    const saveGridChanges = async () => {
      // Get all current values from the form
      const gridCards = document.querySelectorAll('.grid-item-card');
      gridItems = Array.from(gridCards).map(card => {
        const id = card.dataset.id;
        const img = card.querySelector('img');
        const titleInput = card.querySelector('.item-title');
        const content = card.editor ? card.editor.getData() : '';
        
        return {
          id: id,
          url: img.src,
          title: titleInput.value,
          content: content
        };
      });

      const urlParams = new URLSearchParams(window.location.search);
      const categoryId = urlParams.get('categoryId');
      
      // Show loading state
      saveGridBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';
      saveGridBtn.disabled = true;
      
      const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MDQ5MWRmMzljZmYwNTljMDY1NWZkMSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTc0NTMyMDAwMywiZXhwIjoxNzQ1NDA2NDAzfQ.5V9SyTCRvPWGFMzOeIF53PAAyie1XQWurRrBCE09axM';
      
      try {
        if (categoryId && !contentId) {
          // Create new section first
          const sectionResponse = await fetch(`/api/sections`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
              name: 'Transform Grid',
              slug: 'transform-grid',
              description: 'Transform Grid section',
              category: categoryId,
              isFolder: false,
              order: 0,
              isActive: true
            })
          });

          if (!sectionResponse.ok) {
            throw new Error('Failed to create section');
          }

          const sectionResult = await sectionResponse.json();

          // Create new content
          const contentResponse = await fetch(`/api/content`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
              section: sectionResult._id,
              slug: 'transform-grid',
              title: 'Transform Grid',
              fields: gridItems.map(item => ({
                id: item.id,
                value: {
                  url: item.url,
                  title: item.title,
                  content: marked.parse(item.content),
                  type: 'grid',
                  key: item.id
                }
              })),
              isActive: true
            })
          });

          if (!contentResponse.ok) {
            throw new Error('Failed to create content');
          }

          const contentResult = await contentResponse.json();
          showAlert('Successfully created Transform Grid Section')
          
          // Update contentId and reload
          contentId = contentResult._id;
          window.location.href = `/transform-grid?id=${contentId}&categoryId=${categoryId}`;
          
        } else if (contentId) {
          // Update existing content
          const response = await fetch(`/api/content/${contentId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}` 
            },
            body: JSON.stringify({
              fields: gridItems.map(item => ({
                id: item.id,
                value: {
                  url: item.url,
                  title: item.title,
                  content: marked.parse(item.content),
                  type: 'grid',
                  key: item.id
                }
              }))
            })
          });
          
          if (!response.ok) {
            throw new Error('Update failed: ' + response.statusText);
          }
          
          const result = await response.json();
          
          // Show success message
          const successAlert = document.getElementById('gridSuccessAlert');
          if (successAlert) {
            successAlert.classList.remove('d-none');
            setTimeout(() => {
              successAlert.classList.add('d-none');
            }, 3000);
          }
        }
      } catch (error) {
        console.error('Error saving grid:', error);
        showAlert('Failed to save changes. Please try again.', 'danger');
      } finally {
        saveGridBtn.innerHTML = '<i class="bi bi-check-circle me-1"></i> Save Changes';
        saveGridBtn.disabled = false;
      }
    };
    
    // Add item to grid
    function addItemToGrid(itemData = {}) {
      const itemId = 'item-' + Date.now();
      
      // Ensure itemData has the correct structure
      if (!itemData.url) {
        itemData = {
          id: itemId,
          url: '/images/placeholder.png',
          title: '',
          content: ''
        };
      }
      
      const gridItem = document.createElement('div');
      gridItem.className = 'col-md-6 grid-item-card';
      gridItem.dataset.id = itemId;
      
      gridItem.innerHTML = `
        <div class="card h-100">
          <div class="position-relative" style="height: 300px;">
            <img src="${itemData.url || '/images/placeholder.png'}" 
                 class="img-cover rounded-top h-100 w-100" 
                 alt="${itemData.title || 'Grid item'}">
            <div class="position-absolute top-0 end-0 m-2">
              <button type="button" class="btn btn-sm btn-primary ai-generate-btn" data-bs-toggle="modal" data-bs-target="#aiPromptModal" data-card-id="${itemId}">
                <i class="fas fa-magic"></i>
              </button>
              <button type="button" class="btn btn-sm btn-success gemini-btn" data-bs-toggle="modal" data-bs-target="#geminiPromptModal" data-card-id="${itemId}">
                <i class="fas fa-robot"></i>
              </button>
            </div>
            <button class="btn-upload-image btn btn-sm btn-primary position-absolute bottom-0 start-0 m-2">
              <i class="bi bi-upload"></i> Upload
            </button>
            <button class="btn-remove-item btn btn-sm btn-danger position-absolute top-0 start-0 m-2">
              <img src="/images/svg/delete.svg" alt="Delete" style="width: 28px; height: 28px; padding: 5px;">
            </button>
          </div>
          <div class="card-body p-4">
            <div class="mb-3">
              <label class="form-label">Title</label>
              <input type="text" 
                     class="form-control item-title" 
                     value="${itemData.title || ''}" 
                     placeholder="Enter title">
            </div>
            <div class="mb-2">
              <label class="form-label">Content</label>
              <div class="content-editor-container">
                <div class="document-editor__toolbar-container"></div>
                <div class="content-editor"></div>
              </div>
            </div>
          </div>
        </div>
      `;
      
      gridContainer.appendChild(gridItem);
      
      // Initialize CKEditor for the content
      const editorContainer = gridItem.querySelector('.content-editor');
      const toolbarContainer = gridItem.querySelector('.document-editor__toolbar-container');
      
      DecoupledEditor
        .create(editorContainer, {
          toolbar: {
            items: [
              'undo', 'redo',
              '|',
              'heading',
              '|',
              'bold', 'italic', 'underline', 'strikethrough',
              '|',
              'link',
              '|',
              'bulletedList', 'numberedList',
              '|',
              'alignment',
              '|',
              'blockQuote',
              '|',
              'removeFormat'
            ],
            shouldNotGroupWhenFull: true
          },
          placeholder: 'Write your content here...'
        })
        .then(editor => {
          // Store editor instance in the card
          gridItem.editor = editor;
          
          // Add the toolbar to the container
          toolbarContainer.appendChild(editor.ui.view.toolbar.element);
          
          // Set initial content if available
          if (itemData.content) {
            editor.setData(itemData.content);
          }
          
          // Add event listener for content changes
          editor.model.document.on('change:data', () => {
            const index = gridItems.findIndex(item => item.id === itemId);
            if (index !== -1) {
              gridItems[index].content = editor.getData();
            }
          });
        })
        .catch(error => {
          console.error('CKEditor initialization failed:', error);
        });
      
      // Add input change handlers
      const titleInput = gridItem.querySelector('.item-title');
      const uploadBtn = gridItem.querySelector('.btn-upload-image');
      
      // Create hidden file input
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      fileInput.style.display = 'none';
      gridItem.appendChild(fileInput);
      
      // Handle image upload
      uploadBtn.addEventListener('click', () => fileInput.click());
      
      // Handle input changes
      titleInput.addEventListener('change', function() {
        const index = gridItems.findIndex(item => item.id === itemId);
        if (index !== -1) {
          gridItems[index].title = this.value;
        }
      });
      
      fileInput.addEventListener('change', async function(e) {
        if (e.target.files && e.target.files[0]) {
          try {
            const file = e.target.files[0];
            const uploadedImage = await uploadImageToServer(file);
            
            if (uploadedImage && uploadedImage.url) {
              const img = gridItem.querySelector('img');
              img.src = uploadedImage.url;
              
              // Update item data
              const index = gridItems.findIndex(item => item.id === itemId);
              if (index !== -1) {
                gridItems[index].url = uploadedImage.url;
              } else {
                gridItems.push({
                  id: itemId,
                  url: uploadedImage.url,
                  title: titleInput.value,
                  content: gridItem.editor ? gridItem.editor.getData() : ''
                });
              }
            }
          } catch (error) {
            console.error('Error uploading image:', error);
          }
        }
      });
      
      // Handle item removal
      gridItem.querySelector('.btn-remove-item').addEventListener('click', () => {
        // Destroy the editor instance before removing the card
        if (gridItem.editor) {
          gridItem.editor.destroy();
        }
        gridItem.remove();
        gridItems = gridItems.filter(item => item.id !== itemId);
      });
    }
    
    // Upload image to server
    async function uploadImageToServer(file) {
      if (!file) return null;
      
      const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4MDQ5MWRmMzljZmYwNTljMDY1NWZkMSIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTc0NTMyMDAwMywiZXhwIjoxNzQ1NDA2NDAzfQ.5V9SyTCRvPWGFMzOeIF53PAAyie1XQWurRrBCE09axM';
      
      const formData = new FormData();
      formData.append('images', file);
      
      try {
        const response = await fetch(`/api/images`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          },
          body: formData
        });
        
        if (!response.ok) {
          throw new Error('Upload failed: ' + response.statusText);
        }
        
        const data = await response.json();
        
        if (data && data.files && data.files.length > 0) {
          return {
            url: data.files[0].url
          };
        }
        
        return null;
      } catch (error) {
        console.error('Error uploading to server:', error);
        return null;
      }
    }
    
    // AI image generation function
    const generateAIImage = async (prompt, cardId) => {
      if (!prompt) {
        showAlert('Please enter a prompt for image generation', 'warning');
        return;
      }

      const generateButton = document.getElementById('generateImageBtn');
      const originalButtonText = generateButton.innerHTML;
      generateButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Generating...';
      generateButton.disabled = true;

      try {
        const response = await fetch('/api/images/generate-image', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prompt: prompt
          })
        });

        if (!response.ok) {
          throw new Error('AI image generation failed');
        }

        const data = await response.json();
        
        if (data.imageData) {
          // Extract the base64 data
          const base64Data = data.imageData.replace(/^data:image\/\w+;base64,/, '');
          const byteCharacters = atob(base64Data);
          const byteArrays = [];
          
          for (let i = 0; i < byteCharacters.length; i++) {
            byteArrays.push(byteCharacters.charCodeAt(i));
          }
          
          const byteArray = new Uint8Array(byteArrays);
          const blob = new Blob([byteArray], { type: 'image/png' });
          const file = new File([blob], 'ai-generated-image.png', { type: 'image/png' });
          
          // Upload the generated image
          const uploadedImage = await uploadImageToServer(file);
          
          if (uploadedImage && uploadedImage.url) {
            // Find the card and update its image
            const card = document.querySelector(`.grid-item-card[data-id="${cardId}"]`);
            if (card) {
              const img = card.querySelector('img');
              img.src = uploadedImage.url;
              
              // Update item data
              const index = gridItems.findIndex(item => item.id === cardId);
              if (index !== -1) {
                gridItems[index].url = uploadedImage.url;
              }
            }
            
            showAlert('AI image generated and uploaded successfully!', 'success');
            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('aiPromptModal'));
            modal.hide();
          }
        }
      } catch (error) {
        console.error('Error generating AI image:', error);
        showAlert('Failed to generate AI image. Please try again.', 'danger');
      } finally {
        generateButton.innerHTML = originalButtonText;
        generateButton.disabled = false;
      }
    };

    // Gemini content generation function
    const generateGeminiContent = async (prompt, cardId) => {
      if (!prompt) {
        showAlert('Please enter a prompt for content generation', 'warning');
        return;
      }

      const generateButton = document.getElementById('generateContentBtn');
      const originalButtonText = generateButton.innerHTML;
      generateButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Generating...';
      generateButton.disabled = true;

      try {
        const response = await fetch(`/api/images/generate-prompt`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            categoryName: 'Transform Grid',
            type: 'content',
            prompt: `Write a compelling, SEO-optimized content (within 600 words) for the title: ${prompt}. Use relevant primary and secondary SEO keywords. Highlight the tool's benefits such as speed, ease of use, realism, and value (e.g., free, online). Focus on engaging language that encourages users to try the tool.
            Return only the content. Do not include a title or any extra text.`
          })
        });

        if (!response.ok) {
          throw new Error('Content generation failed');
        }

        const data = await response.json();
        
        if (data.prompt && data.prompt.candidates && data.prompt.candidates[0] && data.prompt.candidates[0].content && data.prompt.candidates[0].content.parts[0]) {
          const generatedContent = data.prompt.candidates[0].content.parts[0].text;
          
          // Find the card and update its content
          const card = document.querySelector(`.grid-item-card[data-id="${cardId}"]`);
          if (card && card.editor) {
            try {
              // Parse the content using marked
              const parsedContent = marked.parse(generatedContent);
              
              // Set the parsed HTML content in the editor
              card.editor.setData(parsedContent);
              
              // Update the grid items array
              const index = gridItems.findIndex(item => item.id === cardId);
              if (index !== -1) {
                gridItems[index].content = card.editor.getData();
              }
              
              showAlert('Content generated successfully!', 'success');
              // Close the modal
              const modal = bootstrap.Modal.getInstance(document.getElementById('geminiPromptModal'));
              modal.hide();
            } catch (parseError) {
              console.error('Error parsing content:', parseError);
              card.editor.setData(generatedContent);
            }
          }
        }
      } catch (error) {
        console.error('Error generating content:', error);
        showAlert('Failed to generate content. Please try again.', 'danger');
      } finally {
        generateButton.innerHTML = originalButtonText;
        generateButton.disabled = false;
      }
    };

    // Event listeners
    addItemBtn.addEventListener('click', () => addItemToGrid());
    saveGridBtn.addEventListener('click', saveGridChanges);
    
    // Add event listeners for AI generation buttons
    document.getElementById('aiPromptModal').addEventListener('show.bs.modal', function(event) {
      const button = event.relatedTarget;
      const cardId = button.getAttribute('data-card-id');
      this.setAttribute('data-card-id', cardId);
    });

    document.getElementById('generateImageBtn').addEventListener('click', function() {
      const cardId = document.getElementById('aiPromptModal').getAttribute('data-card-id');
      const prompt = document.getElementById('aiPromptInput').value.trim();
      generateAIImage(prompt, cardId);
    });

    // Clear the prompt input when the modal is closed
    document.getElementById('aiPromptModal').addEventListener('hidden.bs.modal', function() {
      document.getElementById('aiPromptInput').value = '';
    });

    // Add event listeners for Gemini buttons
    document.getElementById('geminiPromptModal').addEventListener('show.bs.modal', function(event) {
      const button = event.relatedTarget;
      const cardId = button.getAttribute('data-card-id');
      this.setAttribute('data-card-id', cardId);
    });

    document.getElementById('generateContentBtn').addEventListener('click', function() {
      const cardId = document.getElementById('geminiPromptModal').getAttribute('data-card-id');
      const prompt = document.getElementById('geminiPromptInput').value.trim();
      generateGeminiContent(prompt, cardId);
    });

    // Clear the prompt input when the modal is closed
    document.getElementById('geminiPromptModal').addEventListener('hidden.bs.modal', function() {
      document.getElementById('geminiPromptInput').value = '';
    });
    
    // Load items on page load
    fetchGridItems();
  });
</script>

<!-- Add AI Prompt Modal -->
<div class="modal fade" id="aiPromptModal" tabindex="-1" aria-labelledby="aiPromptModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="aiPromptModalLabel">Generate AI Image</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label for="aiPromptInput" class="form-label">Enter your prompt</label>
          <textarea class="form-control" id="aiPromptInput" rows="3" placeholder="Describe the image you want to generate..."></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="generateImageBtn">
          <i class="fas fa-magic me-2"></i>Generate
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Add Gemini Prompt Modal -->
<div class="modal fade" id="geminiPromptModal" tabindex="-1" aria-labelledby="geminiPromptModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="geminiPromptModalLabel">Generate Content with Gemini AI</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">  
        <div class="mb-3">
          <label for="geminiPromptInput" class="form-label">Enter your prompt</label>
          <textarea class="form-control" id="geminiPromptInput" rows="3" placeholder="Describe the content you want to generate..."></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-success" id="generateContentBtn">
          <i class="fas fa-robot me-2"></i>Generate Content
        </button>
      </div>
    </div>
  </div>
</div>

<style>
  .grid-item-card {
    transition: all 0.2s ease;
    margin-bottom: 2rem;
  }
  
  .grid-item-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 0.5rem 1rem rgba(0,0,0,0.1);
  }
  
  .img-cover {
    object-fit: cover;
  }
  
  .btn-remove-item {
    padding: 0.15rem 0.25rem;
    opacity: 0;
    transition: opacity 0.2s ease;
  }
  
  .grid-item-card:hover .btn-remove-item {
    opacity: 1;
  }
  
  .card {
    border: 1px solid rgba(0,0,0,0.1);
    transition: all 0.2s ease;
  }
  
  .card:hover {
    border-color: rgba(0,0,0,0.2);
  }
  
  .form-label {
    font-weight: 500;
    margin-bottom: 0.5rem;
  }
  
  .form-control {
    border: 1px solid rgba(0,0,0,0.1);
  }
  
  .form-control:focus {
    border-color: #4526B1;
    box-shadow: 0 0 0 0.2rem rgba(69, 38, 177, 0.25);
  }
  
  .alert-container {
    min-width: 300px;
    max-width: 500px;
  }
  
  .alert-container .alert {
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    border: none;
    animation: slideIn 0.3s ease-out;
  }
  
  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  /* CKEditor Styles */
  .content-editor-container {
    border: 1px solid #ced4da;
    border-radius: 0.25rem;
  }
  
  .document-editor__toolbar-container {
    position: sticky;
    top: 0;
    background: white;
    z-index: 1;
    border-bottom: 1px solid #ced4da;
    padding: 0.25rem;
  }
  
  .content-editor {
    min-height: 250px;
    max-height: 500px;
    overflow-y: auto;
    padding: 1rem;
  }
  
  .ck-toolbar {
    border: none !important;
  }
  
  .ck-editor__editable {
    border: none !important;
  }

  /* Responsive adjustments */
  @media (min-width: 768px) {
    .grid-item-card {
      margin-bottom: 2.5rem;
    }
  }

  /* AI Generation Button Styles */
  .ai-generate-btn {
    background-color: rgba(13, 110, 253, 0.8);
    border: none;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
  }

  .ai-generate-btn:hover {
    background-color: rgba(13, 110, 253, 1);
    transform: scale(1.1);
  }

  .ai-generate-btn i {
    font-size: 0.875rem;
  }

  /* Gemini Button Styles */
  .gemini-btn {
    background-color: rgba(25, 135, 84, 0.8);
    border: none;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
    margin-left: 0.25rem;
  }

  .gemini-btn:hover {
    background-color: rgba(25, 135, 84, 1);
    transform: scale(1.1);
  }

  .gemini-btn i {
    font-size: 0.875rem;
  }
</style>